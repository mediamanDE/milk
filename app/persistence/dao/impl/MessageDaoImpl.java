package persistence.dao.impl;

import java.util.Date;
import java.util.List;
import java.util.Map;

import models.ExternalLink;
import models.Group;
import models.Message;
import models.User;
import persistence.dao.api.IMessageDao;
import service.UserService;

import com.mongodb.BasicDBList;
import com.mongodb.BasicDBObject;
import com.mongodb.DB;
import com.mongodb.DBCollection;
import com.mongodb.DBCursor;
import com.mongodb.DBObject;
import java.util.ArrayList;

import org.bson.types.ObjectId;

public class MessageDaoImpl extends BaseDao implements IMessageDao {

    @Override
    public void store(Message message) {
         if (message != null && message.getFrom() != null) {
            DB db = getDatabase();
            DBCollection coll = db.getCollection(COLLECTION_MESSAGES);

            BasicDBObject mongoMessage = new BasicDBObject();

//			Message ID will be generated by Mongo
//			mongoMessage.put(FIELD_MESSAGE_ID, message.get_id());

            List<String> ancestorIds = message.getAncestors();
    		if(ancestorIds != null && ancestorIds.size()>0){
	    			DBObject list = new BasicDBList();
	    			Integer count = new Integer(0);
	    			for (String ancestorId : ancestorIds) {
	    				list.put(count.toString(), ancestorId);
	    			}
	    			mongoMessage.put(FIELD_MESSAGE_ANCESTORS, list);
    		}
            
            mongoMessage.put(FIELD_MESSAGE_FROM, message.getFrom().getOpenId());
//			mongoMessage.put(FIELD_MESSAGE_GROUPS, message.getGroups());
            mongoMessage.put(FIELD_MESSAGE_MESSAGETEXT, message.getMessagetext());
            mongoMessage.put(FIELD_MESSAGE_POSTDATE, message.getPostdate());

            coll.insert(mongoMessage);
        }
    }

    @Override
    public void delete() {
        // TODO Auto-generated method stub
    }

    @Override
    public Message getMessageById(final String messageId) {
        Message returnMessage = null;
        
        DB db = getDatabase();
        DBCollection coll = db.getCollection(COLLECTION_MESSAGES);
        DBObject result;
        ObjectId messageIdObj = new ObjectId(messageId);

        BasicDBObject query = new BasicDBObject();
        query.put(FIELD_MESSAGE_ID, messageIdObj);
        result = coll.findOne(query);
        if (result != null) {
            Map resultMap = result.toMap();

            returnMessage = new Message();
            returnMessage.setId(((ObjectId) resultMap.get(FIELD_MESSAGE_ID)).toString());

			BasicDBList list = (BasicDBList) result.get(FIELD_MESSAGE_ANCESTORS);
			int sizeAncestorIds = (list != null) ? list.size() : 0;
			if (sizeAncestorIds > 0) {
				
				List<String> ancestorIds = new ArrayList<String>(sizeAncestorIds);
				
				for (int i = 0; i < sizeAncestorIds; i++) {
					String dbAncestorId = (String) list.get(i);
					ancestorIds.add(dbAncestorId);
				}
				returnMessage.setAncestors(ancestorIds);
			}

            
            returnMessage.setFrom((User) UserService.getUserByOpenId((String)resultMap.get(FIELD_MESSAGE_FROM)));
//			returnMessage.setGroups((String) resultMap.get(FIELD_MESSAGE_GROUPS));
            returnMessage.setMessagetext((String) resultMap.get(FIELD_MESSAGE_MESSAGETEXT));
			returnMessage.setPostdate((Date) resultMap.get(FIELD_MESSAGE_POSTDATE));
        }
        return returnMessage;
    }

    @Override
    public List<Message> getThread(String messageId) {
        // TODO Auto-generated method stub
        return null;
    }

    /**
     * Get an ordered List of all Messages.
     * 
     * @param orderBy String ASC, DESC
     * @return
     */
    @Override
    public List<Message> getAllMessages(String orderBy) {

        int order = ("ASC" == orderBy) ? 1 : -1;

        String messageId = null;
        List<Message> messagesArray = new ArrayList<Message>();

        DB db = getDatabase();
        DBCollection coll = db.getCollection(COLLECTION_MESSAGES);

        BasicDBObject query = new BasicDBObject();
        BasicDBObject field = new BasicDBObject();
        BasicDBObject sortfield = new BasicDBObject();

        field.put(FIELD_MESSAGE_POSTDATE, order);
        field.put(FIELD_MESSAGE_ID, order);
        
        sortfield.put(FIELD_MESSAGE_POSTDATE, order);
        
        // query: where
        // field: which field(s)
        DBCursor cursor = coll.find(query,field).sort(sortfield);

        messagesArray = getMessages(cursor);

        return messagesArray;

    }

    @Override
    public List<Message> getAllMessagesByGroup(Group group) {
        // TODO Auto-generated method stub
        return null;
    }

    @Override
    public List<Message> getLimitedMessages(int limit, int offset, String orderBy) {

        // db.messages.find().sort({'postdate':-1}).skip(4).limit(2)
        int order = ("ASC" == orderBy) ? 1 : -1;

        List<Message> messagesArray = new ArrayList<Message>();

        DB db = getDatabase();
        DBCollection coll = db.getCollection(COLLECTION_MESSAGES);

        BasicDBObject query = new BasicDBObject();
        BasicDBObject field = new BasicDBObject();
        BasicDBObject sortfield = new BasicDBObject();

        field.put(FIELD_MESSAGE_POSTDATE, order);
        field.put(FIELD_MESSAGE_ID, order);

        sortfield.put(FIELD_MESSAGE_POSTDATE, order);

// query: where
        // field: which field(s)
        DBCursor cursor = coll.find(query,field).sort(sortfield).skip(offset).limit(limit);

        messagesArray = getMessages(cursor);

        return messagesArray;

    }

    /**
     * Get a List of Messages for given cursor.
     * @param cursor
     * @return
     */
    private List<Message> getMessages(DBCursor cursor) {

        String messageId = null;
        List<Message> messagesArray = new ArrayList<Message>();

        while (cursor.hasNext()) {

            BasicDBObject obj = (BasicDBObject) cursor.next();

            Message myMessage = new Message();
            messageId = obj.getString(FIELD_MESSAGE_ID);

            myMessage = getMessageById(messageId);

            if (null != myMessage) {
                messagesArray.add(myMessage);
            }

        }

        return messagesArray;

    }
}
